{"ast":null,"code":"import _slicedToArray from \"/home/boring/webdev/jsprojects/react/travelapp/amadeus-airport-city-search-mern/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/home/boring/webdev/jsprojects/react/travelapp/amadeus-airport-city-search-mern/client/src/pages/search-root.jsx\";\nimport React from \"react\";\nimport SearchTable from \"../components/search-table\";\nimport SearchAutocomplete from \"../components/search-autocomplete\";\nimport { getAmadeusData } from \"../api/amadeus.api\";\nimport axios from \"axios\";\nimport SearchCheckboxes from \"../components/search-checkboxes\"; // Main component \n\nconst SearchRoot = () => {\n  /* \n    With new React API we can define state in functional component like this *React.useState*\n    1. first element in desctructured array - state itself\n    2. second element - dispatch func, that allows us to change state\n    3. we can create as many states as we need\n  */\n  const _React$useState = React.useState({\n    keyword: \"a\",\n    city: true,\n    airport: true,\n    page: 0\n  }),\n        _React$useState2 = _slicedToArray(_React$useState, 2),\n        search = _React$useState2[0],\n        setSearch = _React$useState2[1];\n\n  const _React$useState3 = React.useState({\n    meta: {\n      count: 0\n    },\n    data: []\n  }),\n        _React$useState4 = _slicedToArray(_React$useState3, 2),\n        dataSource = _React$useState4[0],\n        setDataSource = _React$useState4[1];\n\n  const _React$useState5 = React.useState(false),\n        _React$useState6 = _slicedToArray(_React$useState5, 2),\n        loading = _React$useState6[0],\n        setLoading = _React$useState6[1];\n  /* \n    Also React has lifecycle methods. On of them is *useEffect* - the same as ComponentDidMount | ComponentDidUpdate | ComponentWillUnmount in class components \n    1. First argument is callback func, we define there all logic we need to execute when component mounts\n    2. Second argument - array of dependencies. If one of them changing - we executing callback func again\n     ** If Array is empty - callback will execute only once, when mount\n    ** If you not including second argument - callback will execute each time, when component will change\n     3. We can create as many *useEffect* funcs, as we need\n  */\n\n\n  React.useEffect(() => {\n    // Turn on loader animation\n    setLoading(true);\n    /* Getting data from amadeus api.\n       out - our data that coming from backend.\n       source - token for cancelation request.\n    */\n\n    const _getAmadeusData = getAmadeusData(search),\n          out = _getAmadeusData.out,\n          source = _getAmadeusData.source;\n\n    out.then(res => {\n      // If we send too many request to the api per second - we will get an error and app will break\n      // Therefore we implemented simple check to prevent error on client side.\n      if (!res.data.code) {\n        setDataSource(res.data); // dispatching data to components state\n      }\n\n      setLoading(false);\n    }).catch(err => {\n      axios.isCancel(err);\n      setLoading(false);\n    }); // If we returning function from *useEffect* - then this func will execute, when component will unmount\n\n    return () => {\n      source.cancel();\n    };\n  }, [search]);\n  return React.createElement(\"div\", {\n    className: \"container\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 72\n    },\n    __self: this\n  }, React.createElement(\"div\", {\n    className: \"search-panel\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 73\n    },\n    __self: this\n  }, React.createElement(SearchAutocomplete, {\n    search: search,\n    setSearch: setSearch,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 74\n    },\n    __self: this\n  }), React.createElement(SearchCheckboxes, {\n    search: search,\n    setSearch: setSearch,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 75\n    },\n    __self: this\n  })), React.createElement(SearchTable, {\n    dataSource: dataSource,\n    search: search,\n    setSearch: setSearch,\n    loading: loading,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 77\n    },\n    __self: this\n  }));\n};\n\nexport default SearchRoot;","map":{"version":3,"sources":["/home/boring/webdev/jsprojects/react/travelapp/amadeus-airport-city-search-mern/client/src/pages/search-root.jsx"],"names":["React","SearchTable","SearchAutocomplete","getAmadeusData","axios","SearchCheckboxes","SearchRoot","useState","keyword","city","airport","page","search","setSearch","meta","count","data","dataSource","setDataSource","loading","setLoading","useEffect","out","source","then","res","code","catch","err","isCancel","cancel"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,WAAP,MAAwB,4BAAxB;AACA,OAAOC,kBAAP,MAA+B,mCAA/B;AACA,SAASC,cAAT,QAA+B,oBAA/B;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,gBAAP,MAA6B,iCAA7B,C,CAEA;;AACA,MAAMC,UAAU,GAAG,MAAM;AAEvB;;;;;;AAFuB,0BAQKN,KAAK,CAACO,QAAN,CAAe;AACzCC,IAAAA,OAAO,EAAE,GADgC;AAEzCC,IAAAA,IAAI,EAAE,IAFmC;AAGzCC,IAAAA,OAAO,EAAE,IAHgC;AAIzCC,IAAAA,IAAI,EAAE;AAJmC,GAAf,CARL;AAAA;AAAA,QAQhBC,MARgB;AAAA,QAQRC,SARQ;;AAAA,2BAeab,KAAK,CAACO,QAAN,CAAe;AACjDO,IAAAA,IAAI,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAD2C;AAEjDC,IAAAA,IAAI,EAAE;AAF2C,GAAf,CAfb;AAAA;AAAA,QAehBC,UAfgB;AAAA,QAeJC,aAfI;;AAAA,2BAoBOlB,KAAK,CAACO,QAAN,CAAe,KAAf,CApBP;AAAA;AAAA,QAoBhBY,OApBgB;AAAA,QAoBPC,UApBO;AAsBvB;;;;;;;;;;AAUApB,EAAAA,KAAK,CAACqB,SAAN,CAAgB,MAAM;AACpB;AACAD,IAAAA,UAAU,CAAC,IAAD,CAAV;AAGA;;;;;AALoB,4BAUIjB,cAAc,CAACS,MAAD,CAVlB;AAAA,UAUZU,GAVY,mBAUZA,GAVY;AAAA,UAUPC,MAVO,mBAUPA,MAVO;;AAYpBD,IAAAA,GAAG,CAACE,IAAJ,CAASC,GAAG,IAAI;AACd;AACA;AACA,UAAI,CAACA,GAAG,CAACT,IAAJ,CAASU,IAAd,EAAoB;AAClBR,QAAAA,aAAa,CAACO,GAAG,CAACT,IAAL,CAAb,CADkB,CACO;AAC1B;;AACDI,MAAAA,UAAU,CAAC,KAAD,CAAV;AACD,KAPD,EAOGO,KAPH,CAOSC,GAAG,IAAI;AACdxB,MAAAA,KAAK,CAACyB,QAAN,CAAeD,GAAf;AACAR,MAAAA,UAAU,CAAC,KAAD,CAAV;AACD,KAVD,EAZoB,CAwBpB;;AACA,WAAO,MAAM;AACXG,MAAAA,MAAM,CAACO,MAAP;AACD,KAFD;AAGD,GA5BD,EA4BG,CAAClB,MAAD,CA5BH;AA8BA,SACE;AAAK,IAAA,SAAS,EAAC,WAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACE;AAAK,IAAA,SAAS,EAAC,cAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KACE,oBAAC,kBAAD;AAAoB,IAAA,MAAM,EAAEA,MAA5B;AAAoC,IAAA,SAAS,EAAEC,SAA/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADF,EAEE,oBAAC,gBAAD;AAAkB,IAAA,MAAM,EAAED,MAA1B;AAAkC,IAAA,SAAS,EAAEC,SAA7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAFF,CADF,EAKE,oBAAC,WAAD;AAAa,IAAA,UAAU,EAAEI,UAAzB;AAAqC,IAAA,MAAM,EAAEL,MAA7C;AAAqD,IAAA,SAAS,EAAEC,SAAhE;AAA2E,IAAA,OAAO,EAAEM,OAApF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IALF,CADF;AASD,CAvED;;AAyEA,eAAeb,UAAf","sourcesContent":["import React from \"react\";\nimport SearchTable from \"../components/search-table\";\nimport SearchAutocomplete from \"../components/search-autocomplete\";\nimport { getAmadeusData } from \"../api/amadeus.api\";\nimport axios from \"axios\"\nimport SearchCheckboxes from \"../components/search-checkboxes\";\n\n// Main component \nconst SearchRoot = () => {\n\n  /* \n    With new React API we can define state in functional component like this *React.useState*\n    1. first element in desctructured array - state itself\n    2. second element - dispatch func, that allows us to change state\n    3. we can create as many states as we need\n  */\n  const [search, setSearch] = React.useState({\n    keyword: \"a\",\n    city: true,\n    airport: true,\n    page: 0\n  });\n\n  const [dataSource, setDataSource] = React.useState({\n    meta: { count: 0 },\n    data: []\n  });\n\n  const [loading, setLoading] = React.useState(false)\n\n  /* \n    Also React has lifecycle methods. On of them is *useEffect* - the same as ComponentDidMount | ComponentDidUpdate | ComponentWillUnmount in class components \n    1. First argument is callback func, we define there all logic we need to execute when component mounts\n    2. Second argument - array of dependencies. If one of them changing - we executing callback func again\n\n    ** If Array is empty - callback will execute only once, when mount\n    ** If you not including second argument - callback will execute each time, when component will change\n\n    3. We can create as many *useEffect* funcs, as we need\n  */\n  React.useEffect(() => {\n    // Turn on loader animation\n    setLoading(true)\n\n\n    /* Getting data from amadeus api.\n       out - our data that coming from backend.\n       source - token for cancelation request.\n    */\n\n    const { out, source } = getAmadeusData(search);\n\n    out.then(res => {\n      // If we send too many request to the api per second - we will get an error and app will break\n      // Therefore we implemented simple check to prevent error on client side.\n      if (!res.data.code) {\n        setDataSource(res.data); // dispatching data to components state\n      }\n      setLoading(false)\n    }).catch(err => {\n      axios.isCancel(err);\n      setLoading(false)\n    });\n\n    // If we returning function from *useEffect* - then this func will execute, when component will unmount\n    return () => {\n      source.cancel()\n    };\n  }, [search]);\n\n  return (\n    <div className=\"container\">\n      <div className=\"search-panel\">\n        <SearchAutocomplete search={search} setSearch={setSearch} />\n        <SearchCheckboxes search={search} setSearch={setSearch} />\n      </div>\n      <SearchTable dataSource={dataSource} search={search} setSearch={setSearch} loading={loading} />\n    </div>\n  );\n};\n\nexport default SearchRoot;\n"]},"metadata":{},"sourceType":"module"}