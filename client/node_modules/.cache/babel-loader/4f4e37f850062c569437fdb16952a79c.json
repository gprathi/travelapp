{"ast":null,"code":"import _slicedToArray from\"/home/boring/webdev/jsprojects/react/travelapp/amadeus-airport-city-search-mern/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React from\"react\";import SearchTable from\"../components/search-table\";import SearchAutocomplete from\"../components/search-autocomplete\";import{getAmadeusData}from\"../api/amadeus.api\";import axios from\"axios\";import SearchCheckboxes from\"../components/search-checkboxes\";// Main component \nvar SearchRoot=function SearchRoot(){/* \n    With new React API we can define state in functional component like this *React.useState*\n    1. first element in desctructured array - state itself\n    2. second element - dispatch func, that allows us to change state\n    3. we can create as many states as we need\n  */var _React$useState=React.useState({keyword:\"a\",city:true,airport:true,page:0}),_React$useState2=_slicedToArray(_React$useState,2),search=_React$useState2[0],setSearch=_React$useState2[1];var _React$useState3=React.useState({meta:{count:0},data:[]}),_React$useState4=_slicedToArray(_React$useState3,2),dataSource=_React$useState4[0],setDataSource=_React$useState4[1];var _React$useState5=React.useState(false),_React$useState6=_slicedToArray(_React$useState5,2),loading=_React$useState6[0],setLoading=_React$useState6[1];/* \n    Also React has lifecycle methods. On of them is *useEffect* - the same as ComponentDidMount | ComponentDidUpdate | ComponentWillUnmount in class components \n    1. First argument is callback func, we define there all logic we need to execute when component mounts\n    2. Second argument - array of dependencies. If one of them changing - we executing callback func again\n\n    ** If Array is empty - callback will execute only once, when mount\n    ** If you not including second argument - callback will execute each time, when component will change\n\n    3. We can create as many *useEffect* funcs, as we need\n  */React.useEffect(function(){// Turn on loader animation\nsetLoading(true);/* Getting data from amadeus api.\n       out - our data that coming from backend.\n       source - token for cancelation request.\n    */var _getAmadeusData=getAmadeusData(search),out=_getAmadeusData.out,source=_getAmadeusData.source;out.then(function(res){// If we send too many request to the api per second - we will get an error and app will break\n// Therefore we implemented simple check to prevent error on client side.\nif(!res.data.code){setDataSource(res.data);// dispatching data to components state\n}setLoading(false);}).catch(function(err){axios.isCancel(err);setLoading(false);});// If we returning function from *useEffect* - then this func will execute, when component will unmount\nreturn function(){source.cancel();};},[search]);return React.createElement(\"div\",{className:\"container\"},React.createElement(\"div\",{className:\"search-panel\"},React.createElement(SearchAutocomplete,{search:search,setSearch:setSearch}),React.createElement(SearchCheckboxes,{search:search,setSearch:setSearch})),React.createElement(SearchTable,{dataSource:dataSource,search:search,setSearch:setSearch,loading:loading}));};export default SearchRoot;","map":{"version":3,"sources":["/home/boring/webdev/jsprojects/react/travelapp/amadeus-airport-city-search-mern/client/src/pages/search-root.jsx"],"names":["React","SearchTable","SearchAutocomplete","getAmadeusData","axios","SearchCheckboxes","SearchRoot","useState","keyword","city","airport","page","search","setSearch","meta","count","data","dataSource","setDataSource","loading","setLoading","useEffect","out","source","then","res","code","catch","err","isCancel","cancel"],"mappings":"6MAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,MAAOC,CAAAA,WAAP,KAAwB,4BAAxB,CACA,MAAOC,CAAAA,kBAAP,KAA+B,mCAA/B,CACA,OAASC,cAAT,KAA+B,oBAA/B,CACA,MAAOC,CAAAA,KAAP,KAAkB,OAAlB,CACA,MAAOC,CAAAA,gBAAP,KAA6B,iCAA7B,CAEA;AACA,GAAMC,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,EAAM,CAEvB;;;;;IAFuB,oBAQKN,KAAK,CAACO,QAAN,CAAe,CACzCC,OAAO,CAAE,GADgC,CAEzCC,IAAI,CAAE,IAFmC,CAGzCC,OAAO,CAAE,IAHgC,CAIzCC,IAAI,CAAE,CAJmC,CAAf,CARL,oDAQhBC,MARgB,qBAQRC,SARQ,0CAeab,KAAK,CAACO,QAAN,CAAe,CACjDO,IAAI,CAAE,CAAEC,KAAK,CAAE,CAAT,CAD2C,CAEjDC,IAAI,CAAE,EAF2C,CAAf,CAfb,qDAehBC,UAfgB,qBAeJC,aAfI,0CAoBOlB,KAAK,CAACO,QAAN,CAAe,KAAf,CApBP,qDAoBhBY,OApBgB,qBAoBPC,UApBO,qBAsBvB;;;;;;;;;IAUApB,KAAK,CAACqB,SAAN,CAAgB,UAAM,CACpB;AACAD,UAAU,CAAC,IAAD,CAAV,CAGA;;;MALoB,oBAUIjB,cAAc,CAACS,MAAD,CAVlB,CAUZU,GAVY,iBAUZA,GAVY,CAUPC,MAVO,iBAUPA,MAVO,CAYpBD,GAAG,CAACE,IAAJ,CAAS,SAAAC,GAAG,CAAI,CACd;AACA;AACA,GAAI,CAACA,GAAG,CAACT,IAAJ,CAASU,IAAd,CAAoB,CAClBR,aAAa,CAACO,GAAG,CAACT,IAAL,CAAb,CAAyB;AAC1B,CACDI,UAAU,CAAC,KAAD,CAAV,CACD,CAPD,EAOGO,KAPH,CAOS,SAAAC,GAAG,CAAI,CACdxB,KAAK,CAACyB,QAAN,CAAeD,GAAf,EACAR,UAAU,CAAC,KAAD,CAAV,CACD,CAVD,EAYA;AACA,MAAO,WAAM,CACXG,MAAM,CAACO,MAAP,GACD,CAFD,CAGD,CA5BD,CA4BG,CAAClB,MAAD,CA5BH,EA8BA,MACE,4BAAK,SAAS,CAAC,WAAf,EACE,2BAAK,SAAS,CAAC,cAAf,EACE,oBAAC,kBAAD,EAAoB,MAAM,CAAEA,MAA5B,CAAoC,SAAS,CAAEC,SAA/C,EADF,CAEE,oBAAC,gBAAD,EAAkB,MAAM,CAAED,MAA1B,CAAkC,SAAS,CAAEC,SAA7C,EAFF,CADF,CAKE,oBAAC,WAAD,EAAa,UAAU,CAAEI,UAAzB,CAAqC,MAAM,CAAEL,MAA7C,CAAqD,SAAS,CAAEC,SAAhE,CAA2E,OAAO,CAAEM,OAApF,EALF,CADF,CASD,CAvED,CAyEA,cAAeb,CAAAA,UAAf","sourcesContent":["import React from \"react\";\nimport SearchTable from \"../components/search-table\";\nimport SearchAutocomplete from \"../components/search-autocomplete\";\nimport { getAmadeusData } from \"../api/amadeus.api\";\nimport axios from \"axios\"\nimport SearchCheckboxes from \"../components/search-checkboxes\";\n\n// Main component \nconst SearchRoot = () => {\n\n  /* \n    With new React API we can define state in functional component like this *React.useState*\n    1. first element in desctructured array - state itself\n    2. second element - dispatch func, that allows us to change state\n    3. we can create as many states as we need\n  */\n  const [search, setSearch] = React.useState({\n    keyword: \"a\",\n    city: true,\n    airport: true,\n    page: 0\n  });\n\n  const [dataSource, setDataSource] = React.useState({\n    meta: { count: 0 },\n    data: []\n  });\n\n  const [loading, setLoading] = React.useState(false)\n\n  /* \n    Also React has lifecycle methods. On of them is *useEffect* - the same as ComponentDidMount | ComponentDidUpdate | ComponentWillUnmount in class components \n    1. First argument is callback func, we define there all logic we need to execute when component mounts\n    2. Second argument - array of dependencies. If one of them changing - we executing callback func again\n\n    ** If Array is empty - callback will execute only once, when mount\n    ** If you not including second argument - callback will execute each time, when component will change\n\n    3. We can create as many *useEffect* funcs, as we need\n  */\n  React.useEffect(() => {\n    // Turn on loader animation\n    setLoading(true)\n\n\n    /* Getting data from amadeus api.\n       out - our data that coming from backend.\n       source - token for cancelation request.\n    */\n\n    const { out, source } = getAmadeusData(search);\n\n    out.then(res => {\n      // If we send too many request to the api per second - we will get an error and app will break\n      // Therefore we implemented simple check to prevent error on client side.\n      if (!res.data.code) {\n        setDataSource(res.data); // dispatching data to components state\n      }\n      setLoading(false)\n    }).catch(err => {\n      axios.isCancel(err);\n      setLoading(false)\n    });\n\n    // If we returning function from *useEffect* - then this func will execute, when component will unmount\n    return () => {\n      source.cancel()\n    };\n  }, [search]);\n\n  return (\n    <div className=\"container\">\n      <div className=\"search-panel\">\n        <SearchAutocomplete search={search} setSearch={setSearch} />\n        <SearchCheckboxes search={search} setSearch={setSearch} />\n      </div>\n      <SearchTable dataSource={dataSource} search={search} setSearch={setSearch} loading={loading} />\n    </div>\n  );\n};\n\nexport default SearchRoot;\n"]},"metadata":{},"sourceType":"module"}